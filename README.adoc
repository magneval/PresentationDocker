// ---
// layout: master
// title: Présentation VM et docker
// :backend: deckjs
// ---
:revealjs_mouseWheel: true
:revealjs_history: true
:revealjs_hideAddressBar: true
:imagesdir: ./images


= Présentation VM Docker

:link-github-project-ghpages: https://magneval.github.io/PresentationDocker
:link-demo-html: {link-github-project-ghpages}/demo.html
:link-demo-pdf: {link-github-project-ghpages}/demo.pdf
:link-demo-adoc: https://raw.githubusercontent.com/magneval/PresentationDocker/master/demo.adoc

== Présentation Docker

Charles de MAGNEVAL +
Charles.de_magneval@open-groupe.com +
v1.0, 2017-04-10 +
 +
https://github.com/magneval/

=== Plan
[%step]
* historique
* la virtualisation
* les hypervirseurs
* l'approche container
* le cloud

== Historique

=== l'ordinateur 8 bits
[%step]
* un processeur
* la RAM
* la ROM
* le stockage de masse
* le programme

=== la version 16 bits
[%step]
* le multi-tache
* le réseau
* pas un programme, un OS

=== les OS
* dos
* OS400
* UNIX
* Windows
* Linux
* Mac OS X

[NOTE.speaker]
--
Apparition d'api sur les couches basses +
drivers +
standardisation
--

== la virtualisation

=== la virtualisation

* La migration IBM 36 vers IBM38 Oblige IBM a faire le premier émulateur.

* On peut faire tourner une machine dans une autre. +
La machine devient un simple programme 

=== !

image::https://upload.wikimedia.org/wikipedia/commons/5/5c/Diagramme_ArchiEmulateur.png[canvas,size=contain]

=== la virtualisation

Il existe de nombreuses solutions :

* VMware
* Qemu
* VirtualBox
* Virtual PC

[NOTE.speaker]
--
On utilise tous une JVM
--

=== les hypervirseurs

* L'approche est similaire, mais l'OS est allégé pour permettre un accès plus rapide aux couches basse du système et donc améliorer les performances. 

* Cette technique peut aussi être aidée par des instructions spécial dans le cœur du processeur permettant un changement de contexte pour passer d'un OS a l'autre

=== !

image::https://upload.wikimedia.org/wikipedia/commons/f/fa/Diagramme_ArchiHyperviseur.png[canvas,size=contain]

=== les hypervirseurs

Les plus courants sont :

* VMware ESX serveur
* Xen (Citrix)
* Microsoft Hyper-V Server

=== l'approche container

Ici plus de couche intermédiaires, on sépare juste le programme des autres

=== !

image::https://upload.wikimedia.org/wikipedia/commons/3/38/Diagramme_ArchiIsolateur.png[canvas,size=contain]

=== l'approche container

L'approche existe depuis longtemps :

* chroot
* BSD Jail
* Zone Solaris 
* LXC

== Docker

=== !

Solution basée sur des techniques existantes dans le noyau Linux et éprouvées :

* LXC,
* CGgroup,
* virtualisation du réseau,
* UnionFS,
* ...

=== Approche légère

Il s'appuie plutôt sur les fonctionnalités du noyau et utilise l'isolation de ressources :

* le processeur,
* la mémoire,
* les entrées et sorties
* les connexions réseaux

=== Docker

gestion des espaces de noms séparés pour isoler le système d'exploitation tel que vu par l'application

Il peut tourner sous d'autre plate-forme comme Mac Os X ou Windows (mais via une VM Linux)

=== Les briques de Docker

* Le Registry
* Les Images
* Les Containers

=== Docker Registry

* Centralisation des images

* possibilité de :
** puller
** pusher

=== Docker Images

* ensembles de couches contenant le système de fichier
* compose a partir
** de couches de bases
** d'action 
* créer a partir de docker file
* utilisation du copy-on-write

[NOTE.speaker]
--
Cette image est compose d'une image disque basique agrémenter d'actions d'installations complémentaires.
Le processus est définis par le "Docker file".
--

=== Le Docker File

Contient :

* l'image de base
* la configuration
* les services réseaux (ports ouvert)
* Les dossiers Partages
* Le Programme lancer dans le container

[NOTE.speaker]
--
Une fois l'image généré, elle peut être réutiliser autant de fois que souhaite par le principe du COW.
Le Copy On Write, permet de ne faire une copie que de ce qui doit être modifier et donc de réduire la taille de deux image différentes a la taille des fichiers modifies.
Une même image peut être référencer dans la création de nombreux container
--

=== Exemple de Docker File

[source, docker, numbered]
--
FROM magneval/openjdk8

MAINTAINER magneval

RUN apt-get install -y tomcat8
RUN    mkdir -p /home/developer

ADD activiti-5.19.0.2.zip activiti.zip
RUN unzip activiti.zip

RUN cp activiti-5.19.0.2/wars/activiti-* /var/lib/tomcat8/webapps/
ENV CATALINA_BASE /var/lib/tomcat8/
VOLUME /exports

CMD /usr/share/tomcat8/bin/catalina.sh  run
--

[NOTE.speaker]
--
Les couches d'images peuvent être partage pour éviter de le recréé a chaque fois.
Le "Docker file" contient aussi la définition des ports réseau présenté et des dossier partage entre le système hôte et le container.
```ENTRYPOINT ["/usr/local/bin/nfs_setup"]```
--

== les commandes Docker

=== la gestion des images

search::
Search for an image on the Docker Hub
build::
Build an image from a Dockerfile
tag::
Tag an image into a repository
history::
Show the history of an image

=== la gestion des images

push::
Push an image or a repository to a Docker registry server
pull::
Pull an image or a repository from a Docker registry server
images::
List images

=== la gestion des images

save::
Save an image to a tar archive
load::
Load an image from a tar archive
rmi::
Remove one or more images

=== pour les instances

run::
Run a command in a new container
exec::
Run a command in an existing container
ps::
List containers
top::
Lookup the running processes of a container

=== pour les instances

port::
Lookup the public-facing port that is NAT-ed to PRIVATE_PORT
cp::
Copy files/folders from a container's filesystem to the host path
attach::
Attach to a running container

=== pour les instances

commit::
Create a new image from a container's changes
stop::
Stop a running container
start::
Start a stopped container
restart::
Restart a running container

=== pour les instances

pause::
Pause all processes within a container
unpause::
Unpause a paused container
kill::
Kill a running container
rm::
Remove one or more containers



[NOTE.speaker]
--
    create    Create a new container
    diff      Inspect changes on a container's filesystem
    events    Get real time events from the server
    export    Stream the contents of a container as a tar archive
    import    Create a new filesystem image from the contents of a tarball
    info      Display system-wide information
    inspect   Return low-level information on a container
    login     Register or log in to a Docker registry server
    logout    Log out from a Docker registry server
    logs      Fetch the logs of a container
    version   Show the Docker version information
    wait      Block until a container stops, then print its exit code
--

=== !

image::commandes-docker.gif[canvas,size=contain]


== Docker Compose


== Docker Swarm


== le cloud


